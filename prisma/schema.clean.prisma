generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
}

enum ProfileType {
  VIEWER
  CREATOR
  PROFESSIONAL
  SHOP
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum PreferenceGender {
  MALE
  FEMALE
  ALL
  OTHER
}

enum PaymentStatus {
  PENDING
  VERIFYING
  PAID
  FAILED
}

enum MediaType {
  IMAGE
  VIDEO
}

enum PostType {
  IMAGE
  VIDEO
}

enum NotificationType {
  SUBSCRIPTION_STARTED
  SUBSCRIPTION_RENEWED
  MESSAGE_RECEIVED
  POST_PUBLISHED
  SERVICE_PUBLISHED
}

enum PaymentIntentPurpose {
  CREATOR_SUBSCRIPTION
  SHOP_PLAN
}

enum PaymentIntentStatus {
  PENDING
  PAID
  FAILED
  EXPIRED
}

model User {
  id                  String            @id @default(uuid()) @db.Uuid
  email               String            @unique
  username            String            @unique
  passwordHash        String
  displayName         String?
  phone               String?
  gender              Gender?
  preferenceGender    PreferenceGender?
  profileType         ProfileType       @default(VIEWER)
  address             String?
  city                String?
  latitude            Float?
  longitude           Float?
  avatarUrl           String?
  coverUrl            String?
  bio                 String?
  serviceCategory     String?
  serviceDescription  String?
  subscriptionPrice   Int?              @default(2500)
  shopTrialEndsAt     DateTime?
  termsAcceptedAt     DateTime?
  allowFreeMessages   Boolean           @default(false)
  role                Role              @default(USER)
  membershipExpiresAt DateTime?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  posts                    Post[]
  payments                 Payment[]
  subscriptions            KhipuSubscription[]
  profileSubscriptions     ProfileSubscription[] @relation("ProfileSubscriptions")
  profileSubscriptionsByMe ProfileSubscription[] @relation("ProfileSubscriber")
  services                 ServiceItem[]
  profileMedia             ProfileMedia[]
  paymentIntents           PaymentIntent[]     @relation("SubscriberPaymentIntents")
  profilePaymentIntents    PaymentIntent[]     @relation("ProfilePaymentIntents")
  sentMessages             Message[]           @relation("SentMessages")
  receivedMessages         Message[]           @relation("ReceivedMessages")
  receivedRatings          ServiceRating[]     @relation("ProfileRatings")
  givenRatings             ServiceRating[]     @relation("GivenRatings")
  notifications            Notification[]
}

model Post {
  id          String   @id @default(uuid()) @db.Uuid
  authorId    String?  @db.Uuid
  title       String
  body        String
  isPublic    Boolean  @default(false)
  price       Int      @default(0)
  type        PostType @default(IMAGE)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  author User? @relation(fields: [authorId], references: [id], onDelete: SetNull)
  media  Media[]
}

model Media {
  id        String    @id @default(uuid()) @db.Uuid
  postId    String    @db.Uuid
  type      MediaType
  url       String
  createdAt DateTime  @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
}

model Payment {
  id                String        @id @default(uuid()) @db.Uuid
  userId            String        @db.Uuid
  subscriptionId    String?       @db.Uuid
  provider          String        @default("khipu")
  providerPaymentId String        @unique
  transactionId     String        @unique
  status            PaymentStatus @default(PENDING)
  amount            Int
  currency          String        @default("CLP")
  paidAt            DateTime?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  user         User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription KhipuSubscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
}

model KhipuSubscription {
  id             String   @id @default(uuid()) @db.Uuid
  userId         String   @db.Uuid
  subscriptionId String   @unique
  status         String
  redirectUrl    String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  payments Payment[]
}

model ProfileSubscription {
  id           String   @id @default(uuid()) @db.Uuid
  subscriberId String   @db.Uuid
  profileId    String   @db.Uuid
  status       String   @default("ACTIVE")
  price        Int
  startedAt    DateTime @default(now())
  expiresAt    DateTime

  subscriber User @relation("ProfileSubscriber", fields: [subscriberId], references: [id], onDelete: Cascade)
  profile    User @relation("ProfileSubscriptions", fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([subscriberId, profileId])
}

model ServiceItem {
  id          String   @id @default(uuid()) @db.Uuid
  ownerId     String   @db.Uuid
  title       String
  description String?
  category    String?
  price       Int?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  media ServiceMedia[]
}

model ProfileMedia {
  id        String    @id @default(uuid()) @db.Uuid
  ownerId   String    @db.Uuid
  type      MediaType
  url       String
  createdAt DateTime  @default(now())

  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
}

model ServiceMedia {
  id            String    @id @default(uuid()) @db.Uuid
  serviceItemId String    @db.Uuid
  type          MediaType
  url           String
  createdAt     DateTime  @default(now())

  serviceItem ServiceItem @relation(fields: [serviceItemId], references: [id], onDelete: Cascade)
}

model Notification {
  id        String           @id @default(uuid()) @db.Uuid
  userId    String           @db.Uuid
  type      NotificationType
  data      Json?
  readAt    DateTime?
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PaymentIntent {
  id               String               @id @default(uuid()) @db.Uuid
  subscriberId     String               @db.Uuid
  profileId        String?              @db.Uuid
  purpose          PaymentIntentPurpose
  status           PaymentIntentStatus  @default(PENDING)
  amount           Int
  providerPaymentId String?
  paymentUrl       String?
  paidAt           DateTime?
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt

  subscriber User @relation("SubscriberPaymentIntents", fields: [subscriberId], references: [id], onDelete: Cascade)
  profile    User? @relation("ProfilePaymentIntents", fields: [profileId], references: [id], onDelete: SetNull)
}

model Message {
  id        String   @id @default(uuid()) @db.Uuid
  fromId    String   @db.Uuid
  toId      String   @db.Uuid
  body      String
  createdAt DateTime @default(now())
  readAt    DateTime?

  from User @relation("SentMessages", fields: [fromId], references: [id], onDelete: Cascade)
  to   User @relation("ReceivedMessages", fields: [toId], references: [id], onDelete: Cascade)
}

model ServiceRating {
  id        String   @id @default(uuid()) @db.Uuid
  profileId String   @db.Uuid
  raterId   String   @db.Uuid
  rating    Int
  createdAt DateTime @default(now())

  profile User @relation("ProfileRatings", fields: [profileId], references: [id], onDelete: Cascade)
  rater   User @relation("GivenRatings", fields: [raterId], references: [id], onDelete: Cascade)

  @@unique([profileId, raterId])
}
